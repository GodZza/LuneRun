# 单元测试完整指南

## 目录
1. [测试类型](#测试类型)
2. [快速开始](#快速开始)
3. [单元测试原则](#单元测试原则)
4. [集成测试（DynamicTrackUnitTest）](#集成测试dynamictrackunittest)
5. [纯单元测试（PureDynamicTrackTest）](#纯单元测试puredynamictracktest)
6. [创建新测试](#创建新测试)
7. [测试最佳实践](#测试最佳实践)

---

## 测试类型

项目中存在两种测试类型：

### 1. 集成测试 (Integration Tests)
- **文件**: `DynamicTrackUnitTest.cs`
- **场景**: 测试完整的游戏流程和动态轨道系统
- **特点**:
  - 依赖 Level、Player 等复杂对象
  - 测试实际游戏行为
  - 包含可视化 UI 界面
  - 执行时间较长（约25秒）

### 2. 纯单元测试 (Unit Tests)
- **文件**: `PureDynamicTrackTest.cs`
- **场景**: 测试单个组件的核心逻辑
- **特点**:
  - 不依赖游戏对象（Level、Player）
  - 直接测试轨道生成逻辑
  - 隔离、快速、可重复
  - 执行时间短（约3秒）

---

## 快速开始

### 方式 1: 运行集成测试（推荐用于完整验证）

**步骤：**
1. 打开 Unity 编辑器
2. 打开测试场景：`Assets/Scenes/DynamicTrackUnitTest.unity`
3. 点击 `Play` 按钮运行测试
4. 观察控制台输出和屏幕 UI

**结果验证：**
```
========== DynamicTrack 单元测试场景 ==========
初始化测试环境...
[1/4] 创建测试 Level (LevelId: 1)
[2/4] 创建 DynamicTrack (forward=6, backward=2)
[3/4] 初始状态: 8 个轨道段
[4/4] 测试环境准备完成
===========================================
========== 开始测试 ==========
测试结果: 通过 / 失败
===========================================
```

### 方式 2: 运行纯单元测试（推荐用于开发调试）

**步骤：**
1. 打开 Unity 编辑器
2. 打开测试场景：`Assets/Scenes/DynamicTrackUnitTest.unity`
3. 查找场景中的 `PureDynamicTrackTest` GameObject
4. 点击 `Play` 按钮运行测试
5. 观察控制台输出

**结果验证：**
```
========== Pure DynamicTrack Unit Test ==========
[Test 1] 轨道段生成测试
----------------------------------
生成轨道段...
✓ 尝试了 X 次生成，实际生成了 Y 个段

[Test 1.5] 所有生成器测试
----------------------------------
使用所有生成器生成 30 个段...
✓ 尝试了 X 次生成，实际生成了 Y 个段
各类型段分布:
  - ForwardSegment: 15
  - HillSegment: 5
  - CurveSegment: 3
  - ...

[Test 2] 段连接测试
----------------------------------
✓ 第一个段的 connectPart 存在
✓ 段连接存在

[Test 3] 动态加载/卸载测试
----------------------------------
✓ 最终段数: Z
=============================================
所有测试完成！3秒后自动关闭...
```

---

## 单元测试原则

### 核心原则

1. **独立性** - 测试之间不相互影响
2. **隔离性** - 单个测试只测试一个功能点
3. **快速性** - 测试执行时间应该短（<5秒）
4. **可重复性** - 相同输入应该产生相同输出
5. **原子性** - 测试应该验证单一的行为
6. **自动化** - 可以一键运行，不需要手动操作

### 测试模式

```csharp
/// <summary>
/// 测试 1: 轨道段生成
/// </summary>
private void TestTrackGeneration()
{
    Debug.Log("\n[Test 1] 轨道段生成测试");
    Debug.Log("----------------------------------");

    try
    {
        // 1. 准备（Arrange）
        _materials = new Materials();
        _track = new Track();
        _track.SetConnectPart(new Part(...));

        // 2. 执行（Act）
        _generator.Generate(_track, _random, 0.8, 0, 1);

        // 3. 断言（Assert）
        int segmentCount = _track.GetSegments().Count;
        if (segmentCount > 0)
        {
            Debug.Log($"✓ 成功生成 {segmentCount} 个段");
        }
        else
        {
            Debug.LogError($"✗ 未生成任何段");
        }
    }
    catch (System.Exception e)
    {
        // 4. 错误处理
        Debug.LogError($"✗ 测试失败: {e.Message}");
        Debug.LogException(e);
    }
}
```

---

## 集成测试（DynamicTrackUnitTest）

### 测试目标

验证动态轨道系统的完整功能，包括：
- 轨道段自动加载
- 轨道段自动卸载
- 与玩家移动的协调
- 多关卡支持

### 测试参数配置

```csharp
public class DynamicTrackUnitTest : MonoBehaviour
{
    [Header("测试配置")]
    [SerializeField] private bool autoRunOnStart = true;  // 自动运行

    [Header("轨道配置")]
    [SerializeField] private int loadForward = 6;      // 向前加载段数
    [SerializeField] private int keepBackward = 2;      // 向后保留段数

    [Header("测试参数")]
    [SerializeField] private int testSpeed = 20;        // 测试速度（单位/秒）
    [SerializeField] private int testDistance = 500;    // 测试距离
}
```

### 使用场景

**场景 1: 基本功能验证**
- Load Forward: 6
- Keep Backward: 2
- Test Distance: 500
- 验证：轨道能够正常加载和卸载

**场景 2: 长距离测试**
- Load Forward: 6
- Keep Backward: 2
- Test Distance: 2000
- 验证：系统在长距离下稳定运行

**场景 3: 压力测试**
- Load Forward: 10
- Keep Backward: 5
- Test Distance: 3000
- Test Speed: 30
- 验证：系统在高负载下的表现

### 快捷键

- `[T]` - 开始测试
- `[S]` - 查看统计
- `[R]` - 重置测试

### 运行方式

```csharp
// 在编辑器中
Unity Editor -> Assets/Scenes/DynamicTrackUnitTest.unity -> Play

// 在构建后
命令行运行（如果配置了）
```

---

## 纯单元测试（PureDynamicTrackTest）

### 测试目标

验证各个轨道生成器的核心逻辑，不依赖游戏流程：
- 生成器的 CanRun 条件判断
- 生成器的 Generate 执行逻辑
- 轨道段之间的连接关系
- 动态加载/卸载的决策逻辑

### 测试方法结构

```csharp
public class PureDynamicTrackTest : MonoBehaviour
{
    private Track _track;
    private TrackGenerator _generator;
    private Random _random;
    private Materials _materials;

    void Start()
    {
        // 运行所有测试
        TestTrackGeneration();
        TestAllGenerators();
        TestSegmentConnections();
        TestDynamicLoading();
        Cleanup();
        Destroy(gameObject, 3f);
    }

    private void Cleanup()
    {
        // 清理创建的 GameObject
        // 避免编辑器中残留对象
    }
}
```

### 测试用例

#### 测试 1: 轨道段生成
```csharp
private void TestTrackGeneration()
{
    // 目标：验证基本轨道生成功能
    // 预期：至少生成 N 个段
}
```

#### 测试 2: 所有生成器
```csharp
private void TestAllGenerators()
{
    // 目标：验证所有10种生成器都能工作
    // 预期：生成 30 个段，包含多种类型
    // 验证：统计每种生成器生成的段数量
}
```

#### 测试 3: 段连接
```csharp
private void TestSegmentConnections()
{
    // 目标：验证轨道段之间的连接关系
    // 验证点：
    // - connectPart 存在
    // - lastPart 存在
    // - 段之间的连接正确
}
```

#### 测试 4: 动态加载/卸载
```csharp
private void TestDynamicLoading()
{
    // 目标：验证基于玩家位置的动态加载逻辑
    // 模拟：玩家移动 5 步，每步移动 50 单位
    // 验证：距离 < 200 时应该加载新段
}
```

### 测试结果解读

**成功示例：**
```
✓ 尝试了 15 次生成，实际生成了 10 个段
✓ 成功生成 30 个段
各类型段分布:
  - ForwardSegment: 18
  - HillSegment: 4
  - CurveSegment: 3
  - HoleSegment: 2
  - LoopSegment: 1
✓ 第一个段的 connectPart 存在
✓ 段连接存在
✓ 最终段数: 30
```

**失败示例：**
```
✗ 测试失败: Index was out of range
System.IndexOutOfRangeException: ...
```

---

## 创建新测试

### 步骤 1: 创建测试脚本

```csharp
using UnityEngine;
using com.playchilla.runner.track;
using com.playchilla.runner.track.generator;

namespace LuneRun.Tests
{
    public class YourTestName : MonoBehaviour
    {
        void Start()
        {
            // 测试逻辑
        }
    }
}
```

### 步骤 2: 创建测试场景

1. Unity Editor -> File -> New Scene
2. 命名场景（如：`YourTestScene`）
3. 保存到 `Assets/Scenes/`

### 步骤 3: 添加测试对象

1. 在 Hierarchy 右键 -> Create Empty
2. 命名为 `YourTestName`
3. Inspector -> Add Component
4. 搜索并添加你的测试脚本

### 步骤 4: 编写测试方法

```csharp
// 遵循 AAA 模式
private void TestFeatureX()
{
    // Arrange - 准备测试数据
    var testData = SetupTestData();

    // Act - 执行被测试的功能
    var result = YourFunction(testData);

    // Assert - 验证结果
    AssertResult(result);
}

private void AssertResult(object result)
{
    if (expectedCondition)
    {
        Debug.Log($"✓ 测试通过");
    }
    else
    {
        Debug.LogError($"✗ 测试失败: 期望 {expected}, 实际 {actual}");
    }
}
```

---

## 测试最佳实践

### 1. 测试命名

**好的命名：**
```csharp
TestTrackGeneration()
TestSegmentConnections()
TestAllGenerators()
```

**不好的命名：**
```csharp
Test()
Test1()
RunTest()
```

### 2. 使用描述性日志

```csharp
// 清晰的开始标记
Debug.Log("\n[Test 1] 轨道段生成测试");
Debug.Log("----------------------------------");

// 清晰的成功/失败标记
Debug.Log($"✓ 成功生成 {segmentCount} 个段");
Debug.LogError($"✗ 未生成任何段");

// 进度信息
Debug.Log($"步骤 {step + 1}: 玩家位置 Z={playerPos.z}");
```

### 3. 错误处理

```csharp
try
{
    // 测试代码
}
catch (System.Exception e)
{
    // 记录详细的错误信息
    Debug.LogError($"✗ 测试失败: {e.Message}");
    Debug.LogException(e);
    Debug.LogError($"堆栈: {e.StackTrace}");
}
```

### 4. 清理资源

```csharp
private void Cleanup()
{
    if (_track != null)
    {
        foreach (var segment in _track.GetSegments())
        {
            // 清理 GameObject
            if (segment.GetConnectPart()?.visual != null)
            {
                Destroy(segment.GetConnectPart().visual);
            }
            foreach (var part in segment.GetParts())
            {
                if (part.visual != null)
                {
                    Destroy(part.visual);
                }
            }
        }
    }
}

void OnDestroy()
{
    Cleanup();
}
```

### 5. 使用固定随机种子

```csharp
// 确保测试可重复
_random = new Random((uint)1);

// 每次测试都使用相同种子
_generator.Generate(_track, _random, 0.8, segmentCount, 1);
```

### 6. 测试边界条件

```csharp
// 测试空轨道
private void TestEmptyTrack()
{
    var track = new Track();
    // 验证空轨道的行为
}

// 测试单个段
private void TestSingleSegment()
{
    // 生成一个段
    // 验证单个段的情况
}

// 测试极端难度
private void TestExtremeDifficulty()
{
    // 测试 difficulty = 0
    // 测试 difficulty = 1.0
}
```

### 7. 独立性原则

**不好的做法：**
```csharp
private void TestMultipleThings()
{
    // 测试轨道生成
    // 测试玩家移动
    // 测试碰撞检测
    // ❌ 违反单一职责原则
}
```

**好的做法：**
```csharp
private void TestTrackGeneration() { }
private void TestPlayerMovement() { }
private void TestCollisionDetection() { }
```

### 8. 性能监控

```csharp
private void TestPerformance()
{
    System.Diagnostics.Stopwatch sw = new System.Diagnostics.Stopwatch();
    sw.Start();

    // 执行被测试的代码
    for (int i = 0; i < 1000; i++)
    {
        _generator.Generate(_track, _random, 0.8, i, 1);
    }

    sw.Stop();
    Debug.Log($"1000次生成耗时: {sw.ElapsedMilliseconds}ms");
    Debug.Log($"平均每次: {sw.ElapsedMilliseconds / 1000}ms");
}
```

---

## 故障排查

### 问题 1: 测试超时

**症状：** 测试执行时间过长（>30秒）

**解决方案：**
1. 检查是否存在无限循环
2. 减少测试数据量
3. 添加超时保护

```csharp
int maxAttempts = 50;
int attempts = 0;
while (_track.GetSegments().Count < target && attempts < maxAttempts)
{
    _generator.Generate(...);
    attempts++;
}
```

### 问题 2: GameObject 残留

**症状：** 编辑器中创建了大量 GameObject

**解决方案：**
1. 在测试结束时清理所有 GameObject
2. 使用 `Object.DestroyImmediate()` 在编辑器模式下
3. 使用对象池（如果需要）

### 问题 3: 测试不稳定

**症状：** 相同测试，有时通过，有时失败

**原因：**
- 随机种子不一致
- 依赖全局状态
- 测试之间有残留影响

**解决方案：**
```csharp
// 使用固定随机种子
_random = new Random((uint)1);

// 每个测试开始时重新初始化
private void SetupTest()
{
    _track = new Track();
    _materials = new Materials();
}

// 确保测试之间隔离
```

### 问题 4: NullReferenceException

**症状：** 测试报告空引用异常

**解决方案：**
```csharp
// 添加防御性检查
if (_track != null && _track.GetConnectPart() != null)
{
    // 执行操作
}

// 提供默认值
var connectPart = _track.GetConnectPart() ?? new Part(...);
```

---

## 进阶技巧

### 1. 参数化测试

```csharp
private void TestWithParameters(int segments, double difficulty)
{
    // 可以通过不同的参数调用
}

void Start()
{
    TestWithParameters(10, 0.5);
    TestWithParameters(30, 0.8);
}
```

### 2. 数据驱动测试

```csharp
[System.Serializable]
public class TestCase
{
    public string name;
    public int input;
    public int expected;
}

public class DataDrivenTest : MonoBehaviour
{
    [SerializeField] private TestCase[] testCases;

    void Start()
    {
        foreach (var tc in testCases)
        {
            Debug.Log($"测试: {tc.name}");
            var result = TestFunction(tc.input);
            if (result == tc.expected)
                Debug.Log("✓ 通过");
            else
                Debug.LogError($"✗ 失败: 期望 {tc.expected}, 实际 {result}");
        }
    }
}
```

### 3. 自定义断言库

```csharp
public static class TestAssert
{
    public static void Equals(object expected, object actual, string message)
    {
        if (!object.Equals(expected, actual))
        {
            Debug.LogError($"✗ {message}: 期望 {expected}, 实际 {actual}");
        }
        else
        {
            Debug.Log($"✓ {message}");
        }
    }

    public static void GreaterThan(int threshold, int actual, string message)
    {
        if (actual > threshold)
            Debug.Log($"✓ {message}: {actual} > {threshold}");
        else
            Debug.LogError($"✗ {message}: {actual} <= {threshold}");
    }
}

// 使用
TestAssert.Equals(10, actualCount, "段数");
TestAssert.GreaterThan(0, actualCount, "生成段数");
```

---

## 持续集成

### 运行测试脚本

创建命令行脚本批量运行测试：

```bash
#!/bin/bash
# run_tests.sh

UNITY_PATH="/path/to/Unity.exe"
PROJECT_PATH="/path/to/project"

# 运行集成测试
$UNITY_PATH -batchmode -quit \
  -projectPath "$PROJECT_PATH" \
  -executeMethod "DynamicTrackUnitTest.BatchRun" \
  -logFile test_results.log

# 检查结果
grep "测试结果: 通过" test_results.log
```

### 自动化测试报告

```csharp
public class TestReporter
{
    private int totalTests = 0;
    private int passedTests = 0;
    private int failedTests = 0;

    public void LogTestResult(string testName, bool passed)
    {
        totalTests++;
        if (passed) passedTests++;
        else failedTests++;

        Debug.Log($"[{totalTests}] {testName}: {(passed ? "通过" : "失败")}");
    }

    public void PrintSummary()
    {
        Debug.Log("========== 测试摘要 ==========");
        Debug.Log($"总测试数: {totalTests}");
        Debug.Log($"通过: {passedTests}");
        Debug.Log($"失败: {failedTests}");
        Debug.Log($"通过率: {(passedTests * 100.0 / totalTests):F2}%");
        Debug.Log("===============================");
    }
}
```

---

## 总结

### 测试选择指南

| 测试类型 | 适用场景 | 执行时间 | 依赖 |
|---------|---------|---------|------|
| 集成测试 | 验证完整游戏流程 | 长（20-30秒） | Level, Player |
| 纯单元测试 | 验证单个组件逻辑 | 短（2-5秒） | 仅被测组件 |

### 测试开发流程

1. **分析需求** - 明确要测试的功能点
2. **设计测试用例** - 确定输入、预期输出、边界条件
3. **编写测试代码** - 遵循 AAA 模式
4. **运行测试** - 验证初始实现
5. **修复问题** - 根据测试结果调试
6. **添加更多用例** - 覆盖边界条件和异常情况
7. **维护测试** - 随代码演进更新测试

### 关键要点

- ✅ 保持测试简单和专注
- ✅ 使用固定的随机种子确保可重复性
- ✅ 提供清晰的日志输出
- ✅ 在测试结束时清理资源
- ✅ 测试边界条件和错误情况
- ✅ 命名测试清楚地表达其意图
- ✅ 将测试与游戏代码分离
- ✅ 定期运行测试以捕获回归

---

## 相关资源

- `DynamicTrackUnitTest.cs` - 集成测试实现
- `PureDynamicTrackTest.cs` - 纯单元测试实现
- `DynamicTrack单元测试指南.md` - 集成测试详细说明
- `Assets/Scripts/com/playchilla/runner/track/generator/` - 所有轨道生成器

---

**最后更新**: 2026-01-28
**适用版本**: Unity 2022.3+, LuneRun 项目
